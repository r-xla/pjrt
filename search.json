[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 pjrt authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/articles/async-dispatch.html","id":"the-problem-host-device-synchronization","dir":"Articles","previous_headings":"","what":"The Problem: Host-Device Synchronization","title":"Asynchronous Dispatch","text":"running computations accelerators (GPUs, TPUs, even optimized CPU backends), ’s fundamental tension host (R) device (accelerator). default, every operation follows synchronous pattern: R sends data device R waits transfer complete R tells device execute computation R waits computation complete R retrieves result R waits transfer complete creates synchronization bubbles—periods either host device sits idle waiting . training loop, bubbles can significantly reduce throughput: ideal scenario overlaps host device work:","code":"Host:   [prepare batch] [wait...] [prepare batch] [wait...] [prepare batch] Device:        [wait...] [compute]        [wait...] [compute]        [wait...] Host:   [prepare batch 1] [prepare batch 2] [prepare batch 3] [prepare batch 4] Device:          [compute 1] [compute 2] [compute 3] [compute 4]"},{"path":"/articles/async-dispatch.html","id":"asynchronous-dispatch-in-pjrt","dir":"Articles","previous_headings":"","what":"Asynchronous Dispatch in pjrt","title":"Asynchronous Dispatch","text":"{pjrt} package provides async variants key operations return immediately, allowing R continue device works background. operations return promise objects can awaited later.","code":""},{"path":"/articles/async-dispatch.html","id":"the-async-api","dir":"Articles","previous_headings":"Asynchronous Dispatch in pjrt","what":"The Async API","title":"Asynchronous Dispatch","text":"async objects support: value(x) - Block ready return result is_ready(x) - Check complete (non-blocking) as_array(x) - Convert R array (blocks needed)","code":""},{"path":"/articles/async-dispatch.html","id":"basic-example","dir":"Articles","previous_headings":"Asynchronous Dispatch in pjrt","what":"Basic Example","title":"Asynchronous Dispatch","text":"","code":"library(pjrt)  # Compile a simple program src <- r\"( func.func @main(%x: tensor<1000x1000xf32>) -> tensor<1000x1000xf32> {   %0 = \"stablehlo.add\"(%x, %x) : (tensor<1000x1000xf32>, tensor<1000x1000xf32>) -> tensor<1000x1000xf32>   \"func.return\"(%0): (tensor<1000x1000xf32>) -> () } )\" executable <- pjrt_compile(pjrt_program(src))"},{"path":"/articles/async-dispatch.html","id":"synchronous-execution-blocking","dir":"Articles","previous_headings":"Asynchronous Dispatch in pjrt > Basic Example","what":"Synchronous execution (blocking)","title":"Asynchronous Dispatch","text":"","code":"# Each step blocks until complete data <- matrix(runif(1000 * 1000), nrow = 1000) buf <- pjrt_buffer(data, dtype = \"f32\")       # Blocks: wait for transfer result <- pjrt_execute(executable, buf)        # Blocks: wait for computation output <- as_array(result)                     # Blocks: wait for transfer back"},{"path":"/articles/async-dispatch.html","id":"asynchronous-execution-non-blocking","dir":"Articles","previous_headings":"Asynchronous Dispatch in pjrt > Basic Example","what":"Asynchronous execution (non-blocking)","title":"Asynchronous Dispatch","text":"","code":"# Operations return immediately data <- matrix(runif(1000 * 1000), nrow = 1000) transfer <- pjrt_buffer_async(data, dtype = \"f32\")  # Returns immediately result <- pjrt_execute_async(executable, transfer)   # Returns immediately (auto-waits for transfer) async_output <- as_array_async(result)               # Returns immediately  # R can do other work here while device computes...  # Only block when we actually need the value output <- value(async_output)"},{"path":"/articles/async-dispatch.html","id":"smart-input-handling","dir":"Articles","previous_headings":"","what":"Smart Input Handling","title":"Asynchronous Dispatch","text":"key feature async API smart input handling. PJRT manages dependencies internally, can chain async operations without explicit waits: Buffer promises (pjrt_buffer_promise): buffer valid immediately - PJRT handles dependencies internally. R returns immediately without blocking. Buffer promises can passed as_array_async() used inputs executions - PJRT handles dependency. enables true pipelining transfers execution overlap:","code":"# Start two async transfers in parallel buf1 <- pjrt_buffer_async(matrix(1:4, 2, 2), dtype = \"f32\") buf2 <- pjrt_buffer_async(matrix(5:8, 2, 2), dtype = \"f32\")  # Execute with async inputs - auto-waits internally src2 <- r\"( func.func @main(%x: tensor<2x2xf32>, %y: tensor<2x2xf32>) -> tensor<2x2xf32> {   %0 = \"stablehlo.add\"(%x, %y) : (tensor<2x2xf32>, tensor<2x2xf32>) -> tensor<2x2xf32>   \"func.return\"(%0): (tensor<2x2xf32>) -> () } )\" exec2 <- pjrt_compile(pjrt_program(src2))  # Pass async transfers directly - no explicit value() needed result <- pjrt_execute_async(exec2, buf1, buf2) as_array(result) #>      [,1] [,2] #> [1,]    6   10 #> [2,]    8   12"},{"path":"/articles/async-dispatch.html","id":"chaining-execution-with-device-to-host-transfer","dir":"Articles","previous_headings":"Smart Input Handling","what":"Chaining Execution with Device-to-Host Transfer","title":"Asynchronous Dispatch","text":"can also chain async execution async device--host transfer without blocking:","code":"# Start async execution result <- pjrt_execute_async(executable, pjrt_buffer(matrix(runif(1e6), 1000, 1000), dtype = \"f32\"))  # Chain with async device-to-host transfer - returns immediately! # PJRT internally waits for execution to complete before starting transfer async_output <- as_array_async(result)  # R can do other work here...  # Only block when we need the final R array output <- value(async_output)"},{"path":"/articles/async-dispatch.html","id":"when-blocking-happens","dir":"Articles","previous_headings":"","what":"When Blocking Happens","title":"Asynchronous Dispatch","text":"Understanding R blocks crucial writing efficient code. Blocking occurs : Calling value() - Explicitly waiting async operation Calling as_array() buffer - Transfers data device host Printing buffer - Needs read values display operation needs actual data","code":""},{"path":"/articles/async-dispatch.html","id":"avoid-unnecessary-blocking","dir":"Articles","previous_headings":"When Blocking Happens","what":"Avoid Unnecessary Blocking","title":"Asynchronous Dispatch","text":"Bad pattern - Blocking every iteration: Better pattern - Log previous iteration’s metrics:","code":"for (i in seq_len(n_iterations)) {   result <- pjrt_execute(executable, input)   metrics <- as_array(result)  # BLOCKS! Device waits while we transfer   cat(\"Step\", i, \"loss:\", metrics[1], \"\\n\")   input <- prepare_next_batch()  # Device idle during data prep } prev_result <- NULL for (i in seq_len(n_iterations)) {   # Start this iteration's computation   result <- pjrt_execute_async(executable, input)    # While device computes, log PREVIOUS iteration's metrics   if (!is.null(prev_result)) {     metrics <- as_array(prev_result)  # Previous result likely ready     cat(\"Step\", i - 1, \"loss:\", metrics[1], \"\\n\")   }    # Prepare next batch while device still computing   input <- prepare_next_batch()   prev_result <- result }"},{"path":"/articles/async-dispatch.html","id":"checking-readiness","dir":"Articles","previous_headings":"","what":"Checking Readiness","title":"Asynchronous Dispatch","text":"Use is_ready() non-blocking status checks:","code":"# Start async operation transfer <- pjrt_buffer_async(matrix(runif(1e6), 1000, 1000), dtype = \"f32\")  # Check without blocking if (is_ready(transfer)) {   message(\"Transfer complete!\") } else {   message(\"Still transferring...\") } #> Transfer complete!  # Eventually get the value (blocks if needed) buf <- value(transfer)"},{"path":"/articles/async-dispatch.html","id":"full-async-pipeline-example","dir":"Articles","previous_headings":"","what":"Full Async Pipeline Example","title":"Asynchronous Dispatch","text":"’s complete example showing full async pipeline:","code":"library(pjrt)  # Simple multiply-add program src <- r\"( func.func @main(%x: tensor<100x100xf32>, %y: tensor<100x100xf32>) -> tensor<100x100xf32> {   %0 = \"stablehlo.multiply\"(%x, %y) : (tensor<100x100xf32>, tensor<100x100xf32>) -> tensor<100x100xf32>   %1 = \"stablehlo.add\"(%0, %x) : (tensor<100x100xf32>, tensor<100x100xf32>) -> tensor<100x100xf32>   \"func.return\"(%1): (tensor<100x100xf32>) -> () } )\" executable <- pjrt_compile(pjrt_program(src))  # Simulate a mini training loop n_steps <- 5 shape <- c(100L, 100L)  # Initialize with async transfer x <- pjrt_buffer_async(matrix(runif(prod(shape)), shape[1], shape[2]), dtype = \"f32\") y <- pjrt_buffer_async(matrix(runif(prod(shape)), shape[1], shape[2]), dtype = \"f32\")  for (step in seq_len(n_steps)) {   # Execute asynchronously (auto-waits for x and y if needed)   result <- pjrt_execute_async(executable, x, y)    # Use result as input to next iteration (chaining)   x <- result    # Only on last iteration, get the actual value   if (step == n_steps) {     final <- as_array(result)     cat(\"Final result shape:\", dim(final), \"\\n\")     cat(\"Final result[1,1]:\", final[1, 1], \"\\n\")   } } #> Final result shape: 100 100  #> Final result[1,1]: 4.000973"},{"path":"/articles/async-dispatch.html","id":"benchmark-sync-vs-async","dir":"Articles","previous_headings":"","what":"Benchmark: Sync vs Async","title":"Asynchronous Dispatch","text":"Let’s compare synchronous asynchronous execution patterns. ’ll simulate training loop iteration involves preparing input data (simulated Sys.sleep() represent loading disk preprocessing). Note: CPU backend used vignette, async benefit minimal execution fast happens CPU R. real benefit appears GPU/TPU backends : Device computation takes significant time (hundreds milliseconds) device operates independently host CPU True parallelism possible host data preparation device execution","code":"library(pjrt)  # Compile a matrix multiply program src <- r\"( func.func @main(%x: tensor<1000x1000xf32>) -> tensor<1000x1000xf32> {   %0 = \"stablehlo.dot\"(%x, %x) : (tensor<1000x1000xf32>, tensor<1000x1000xf32>) -> tensor<1000x1000xf32>   \"func.return\"(%0): (tensor<1000x1000xf32>) -> () } )\" executable <- pjrt_compile(pjrt_program(src))  n_iterations <- 5 data_prep_time <- 0.02  # Simulate 20ms data preparation  prepare_data <- function() {   Sys.sleep(data_prep_time)   matrix(runif(1000 * 1000), 1000, 1000) }"},{"path":"/articles/async-dispatch.html","id":"synchronous-pattern","dir":"Articles","previous_headings":"Benchmark: Sync vs Async","what":"Synchronous Pattern","title":"Asynchronous Dispatch","text":"operation blocks next can start:","code":"sync_time <- system.time({   for (i in seq_len(n_iterations)) {     data <- prepare_data()     buf <- pjrt_buffer(data, dtype = \"f32\")     result <- pjrt_execute(executable, buf)   }   final <- as_array(result) })  cat(\"Synchronous total time:\", round(sync_time[\"elapsed\"], 3), \"seconds\\n\") #> Synchronous total time: 0.198 seconds"},{"path":"/articles/async-dispatch.html","id":"asynchronous-pattern","dir":"Articles","previous_headings":"Benchmark: Sync vs Async","what":"Asynchronous Pattern","title":"Asynchronous Dispatch","text":"R prepares next batch device computes:","code":"async_time <- system.time({   data <- prepare_data()   buf <- pjrt_buffer_async(data, dtype = \"f32\")   result <- pjrt_execute_async(executable, buf)    for (i in seq_len(n_iterations - 1)) {     data <- prepare_data()     buf <- pjrt_buffer_async(data, dtype = \"f32\")     result <- pjrt_execute_async(executable, buf)   }   final <- as_array(result) })  cat(\"Asynchronous total time:\", round(async_time[\"elapsed\"], 3), \"seconds\\n\") #> Asynchronous total time: 0.196 seconds"},{"path":"/articles/async-dispatch.html","id":"results","dir":"Articles","previous_headings":"Benchmark: Sync vs Async","what":"Results","title":"Asynchronous Dispatch","text":"CPU, patterns similar performance : CPU execution fast (milliseconds) CPU handles R code PJRT execution Little opportunity true parallelism GPU/TPU backends, async pattern shines : Data preparation overlaps execution: GPU runs iteration N, R prepares data N+1 Transfers overlap execution: Host--device transfers happen previous computations run idle time: device stays busy instead waiting R production GPU training loops, async dispatch can provide 1.2-2x speedup depending ratio data preparation time computation time.","code":"cat(\"Sync:\", round(sync_time[\"elapsed\"], 3), \"s, Async:\", round(async_time[\"elapsed\"], 3), \"s\\n\") #> Sync: 0.198 s, Async: 0.196 s"},{"path":"/articles/async-dispatch.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Asynchronous Dispatch","text":"key insight blocking happen late possible. using async operations delaying value() calls, allow device stay busy R prepares next batch work.","code":""},{"path":"/articles/async-dispatch.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further Reading","title":"Asynchronous Dispatch","text":"concepts vignette inspired JAX’s approach asynchronous dispatch: Asynchronous dispatch JAX Training Cookbook: Efficiency via Asynchronous Dispatch","code":""},{"path":"/articles/pjrt.html","id":"main-classes","dir":"Articles","previous_headings":"","what":"Main Classes","title":"Get Started","text":"{pjrt} package provides R interface PJRT. PJRT part OpenXLA project, open source compiler ecosystem machine learning generally Accelerated Linear Algebra (XLA). defines standardized interface serves portability layer allows single framework used different hardware backends. PJRT defines concrete “backend” needs able order usable frontend (like JAX) using PJRT. Anyone can implement specific PJRT plugin (PJRTPlugin) specific hardware backend. using PJRT, plugin loaded shared library wrapped PJRT client (PJRTClient). package, currently support CPU plugins, NVIDIA GPU plugins, Metal (Apple GPU; experimental) plugins. creating plugin upon first use, shared library downloaded cached. plugin can used create client specific platform. Currently, exactly one client per platform stored global cache. client can one devices. relevant CPU clients, principle useful GPUs, although fully supported yet. important operations client supports data handling, compilation execution.","code":"library(pjrt) plugin <- pjrt_plugin(\"cpu\") plugin #> <PJRTPlugin:cpu> client <- plugin_client_create(plugin, \"cpu\") client #> <PJRTClient:cpu> the <- getFromNamespace(\"the\", \"pjrt\") the[[\"clients\"]][[\"cpu\"]] #> <PJRTClient:cpu> the[[\"plugins\"]][[\"cpu\"]] #> <PJRTPlugin:cpu> cpu_devices <- devices(client) cpu_device <- cpu_devices[[1L]]"},{"path":"/articles/pjrt.html","id":"data-handling","dir":"Articles","previous_headings":"Main Classes","what":"Data Handling","title":"Get Started","text":"Using client, can move data host (standard R objects) specific device create buffer (PJRTBuffer) (also known tensor array). buffer type, consists types (homogenous) elements (PJRTElementType) shape. Scalars represented 0-dimensional buffers dimensions can 0. creation, can inspect shape element type buffer. can also move data back host buffer. principle, also supported move data one device another, supported yet.","code":"host_data <- 1:4 device_buffer <- pjrt_buffer(host_data, device = cpu_device, shape = c(2L, 2L), dtype = \"f32\") device_buffer #> PJRTBuffer  #>  1.0000 3.0000 #>  2.0000 4.0000 #> [ CPUf32{2x2} ] shape(device_buffer) #> [1] 2 2 elt_type(device_buffer) #> <f32> device(device_buffer) #> <CpuDevice(id=0)> host_data_from_buffer <- as_array(device_buffer) host_data_from_buffer #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4"},{"path":"/articles/pjrt.html","id":"compilation","dir":"Articles","previous_headings":"Main Classes","what":"Compilation","title":"Get Started","text":"PJRT offers interface compile programs executables. programs can written HLO newer StableHLO. stablehlo package allows easily create StableHLO programs R. , define simple program adds two f32 tensors shape (2, 2). first create program (PJRTProgram) object source code. can’t really anything , except compiling executable (PJRTLoadedExecutable). compilation, need specify client use, executable depends platform GPU binary differ CPU binary.","code":"src <- r\"( func.func @main(   %x: tensor<2x2xf32>,   %y: tensor<2x2xf32> ) -> tensor<2x2xf32> {   %0 = \"stablehlo.add\"(%x, %y) : (tensor<2x2xf32>, tensor<2x2xf32>) -> tensor<2x2xf32>   \"func.return\"(%0): (tensor<2x2xf32>) -> () } )\" program <- pjrt_program(src, format = \"mlir\") program #> PJRTProgram(format=mlir, code_size=221) #>  #> func.func @main( #>   %x: tensor<2x2xf32>, #>   %y: tensor<2x2xf32> #> ) -> tensor<2x2xf32> { #> ... executable <- pjrt_compile(program, client = client) executable #> <PJRTLoadedExecutable>"},{"path":"/articles/pjrt.html","id":"execution","dir":"Articles","previous_headings":"Main Classes","what":"Execution","title":"Get Started","text":"buffers place executable, can execute program. simply pass buffer twice input. default, single outputs unpacked single buffer instead list buffers, can disable setting simplify = FALSE. also possible pass execution options (PJRTExecuteOptions) execution.","code":"result <- pjrt_execute(executable, device_buffer, device_buffer)"},{"path":"/articles/pjrt.html","id":"serialization","dir":"Articles","previous_headings":"","what":"Serialization","title":"Get Started","text":"support reading writing buffers using safetensors format, allows storing named lists buffers.","code":"tmp <- tempfile(fileext = \".safetensors\") safetensors::safe_save_file(list(x = result), tmp, framework = \"pjrt\") reloaded <- safetensors::safe_load_file(tmp, framework = \"pjrt\") reloaded$x #> PJRTBuffer  #>  2.0000 6.0000 #>  4.0000 8.0000 #> [ CPUf32{2x2} ]"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Sebastian Fischer. Maintainer, author. Daniel Falbel. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Fischer S, Falbel D (2026). pjrt: R Interface PJRT. R package version 0.0.0.9000, https://r-xla.github.io/pjrt/.","code":"@Manual{,   title = {pjrt: R Interface to PJRT},   author = {Sebastian Fischer and Daniel Falbel},   year = {2026},   note = {R package version 0.0.0.9000},   url = {https://r-xla.github.io/pjrt/}, }"},{"path":"/index.html","id":"pjrt","dir":"","previous_headings":"","what":"R Interface to PJRT","title":"R Interface to PJRT","text":"{pjrt} package provides R interface PJRT (Pretty much Just another RunTime), allows run XLA stableHLO programs various hardware backends. programs framework hardware agnostic, means can generated ML frameworks jax, run PJRT specified backend (CPU, GPU, etc.). low-level R interface create stableHLO programs, see stablehlo package.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"R Interface to PJRT","text":"GitHub: can also install r-universe, adding code .Rprofile.","code":"pak::pak(\"r-xla/pjrt\") options(repos = c(   rxla = \"https://r-xla.r-universe.dev\",   CRAN = \"https://cloud.r-project.org/\" ))"},{"path":"/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"R Interface to PJRT","text":", create run stableHLO program adds two f32 tensors shape (2, 2).","code":"library(pjrt) src <- r\"( func.func @main(   %x: tensor<2x2xf32>,   %y: tensor<2x2xf32> ) -> tensor<2x2xf32> {   %0 = \"stablehlo.add\"(%x, %y) : (tensor<2x2xf32>, tensor<2x2xf32>) -> tensor<2x2xf32>   \"func.return\"(%0): (tensor<2x2xf32>) -> () } )\" program <- pjrt_program(src, format = \"mlir\") program #> PJRTProgram(format=mlir, code_size=221) #>  #> func.func @main( #>   %x: tensor<2x2xf32>, #>   %y: tensor<2x2xf32> #> ) -> tensor<2x2xf32> { #> ... executable <- pjrt_compile(program, client = \"cpu\")  x <- pjrt_buffer(c(1, 2, 3, 4), shape = c(2, 2), dtype = \"f32\") x #> PJRTBuffer  #>  1.0000 3.0000 #>  2.0000 4.0000 #> [ CPUf32{2x2} ] y <- pjrt_buffer(c(5, 6, 7, 8), shape = c(2, 2), dtype = \"f32\") y #> PJRTBuffer  #>  5.0000 7.0000 #>  6.0000 8.0000 #> [ CPUf32{2x2} ]  pjrt_execute(executable, x, y) #> PJRTBuffer  #>   6.0000 10.0000 #>   8.0000 12.0000 #> [ CPUf32{2x2} ]"},{"path":"/index.html","id":"main-features","dir":"","previous_headings":"","what":"Main Features","title":"R Interface to PJRT","text":"Compile stableHLO programs hardware-specific executables. Provide runtime execute compiled programs. Convert buffers R arrays vectors. Read write buffers using safetensors format.","code":""},{"path":"/index.html","id":"platform-support","dir":"","previous_headings":"","what":"Platform Support","title":"R Interface to PJRT","text":"✅ CPU backend fully supported. ✅ CUDA (NVIDIA GPU) backend fully supported. ✅ CPU backend fully supported. ⚠️ GPU supported via Windows Subsystem Linux (WSL2). ✅ CPU backend supported. ⚠️ Metal (Apple GPU) backend available fully functional.","code":""},{"path":"/index.html","id":"acknowledgements","dir":"","previous_headings":"","what":"Acknowledgements","title":"R Interface to PJRT","text":"development package supported MaRDI. Without OpenXLA, none possible. design {pjrt} package inspired gopjrt implementation. PJRT C API. PJRT C API FFI Extension. Various protobuf files, see ./tools/copy-proto.R ones. Plugin implementations CPU CUDA (using builds zml/pjrt-artifacts). Metal, using plugin implementation jax-metal.","code":""},{"path":"/reference/as.character.PJRTElementType.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert PJRTElementType to string — as.character.PJRTElementType","title":"Convert PJRTElementType to string — as.character.PJRTElementType","text":"Get (lowercase) string representation PJRT element type","code":""},{"path":"/reference/as.character.PJRTElementType.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert PJRTElementType to string — as.character.PJRTElementType","text":"","code":"# S3 method for class 'PJRTElementType' as.character(x, ...)"},{"path":"/reference/as.character.PJRTElementType.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert PJRTElementType to string — as.character.PJRTElementType","text":"x PJRT element type object. ... Additional arguments (unused).","code":""},{"path":"/reference/as.character.PJRTElementType.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert PJRTElementType to string — as.character.PJRTElementType","text":"string representation element type.","code":""},{"path":"/reference/as_array_async.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert buffer to R array asynchronously — as_array_async","title":"Convert buffer to R array asynchronously — as_array_async","text":"Start asynchronous transfer buffer data device host. Returns immediately async array promise object. Use value() get R array (blocks ready). Use is_ready() check transfer completed (non-blocking). Use as_array() alias value(). function also accepts pjrt_buffer_promise objects (pjrt_execute_async() pjrt_buffer_async()), enabling fully async pipelines. transfer chained previous operation without blocking - PJRT handles dependency internally.","code":""},{"path":"/reference/as_array_async.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert buffer to R array asynchronously — as_array_async","text":"","code":"as_array_async(x)"},{"path":"/reference/as_array_async.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert buffer to R array asynchronously — as_array_async","text":"x PJRTBuffer pjrt_buffer_promise object.","code":""},{"path":"/reference/as_array_async.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert buffer to R array asynchronously — as_array_async","text":"pjrt_array_promise object. Call value() get R array.","code":""},{"path":[]},{"path":"/reference/as_array_async.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert buffer to R array asynchronously — as_array_async","text":"","code":"# Create a buffer buf <- pjrt_buffer(c(1.0, 2.0, 3.0, 4.0), shape = c(2, 2), dtype = \"f32\")  # Start async transfer result <- as_array_async(buf)  # Check if ready (non-blocking) is_ready(result) #> [1] TRUE  # Get the R array (blocks if not ready) value(result) #>      [,1] [,2] #> [1,]    1    3 #> [2,]    2    4"},{"path":"/reference/as_pjrt_client.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to PJRT Client — as_pjrt_client","title":"Convert to PJRT Client — as_pjrt_client","text":"Convert platform name PJRT client verify object already client.","code":""},{"path":"/reference/as_pjrt_client.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to PJRT Client — as_pjrt_client","text":"","code":"as_pjrt_client(x)"},{"path":"/reference/as_pjrt_client.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to PJRT Client — as_pjrt_client","text":"x (PJRTClient | character(1)) Either PJRT client object platform name (e.g., \"cpu\", \"cuda\", \"metal\").","code":""},{"path":"/reference/as_pjrt_client.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to PJRT Client — as_pjrt_client","text":"PJRTClient","code":""},{"path":"/reference/as_pjrt_client.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to PJRT Client — as_pjrt_client","text":"","code":"# Convert from platform name client <- as_pjrt_client(\"cpu\") client #> <PJRTClient:cpu>"},{"path":"/reference/as_pjrt_device.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to PJRT Device — as_pjrt_device","title":"Convert to PJRT Device — as_pjrt_device","text":"Convert platform name device PJRT device object.","code":""},{"path":"/reference/as_pjrt_device.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to PJRT Device — as_pjrt_device","text":"","code":"as_pjrt_device(x)"},{"path":"/reference/as_pjrt_device.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to PJRT Device — as_pjrt_device","text":"x (PJRTDevice | character(1) | NULL) Either PJRT device object, platform name (e.g., \"cpu\", \"cuda\", \"metal\"), device specification index (e.g., \"cpu:0\", \"cuda:1\" 0-based indexing), NULL (defaults first CPU device).","code":""},{"path":"/reference/as_pjrt_device.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to PJRT Device — as_pjrt_device","text":"PJRTDevice","code":""},{"path":"/reference/as_pjrt_plugin.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to PJRT Plugin — as_pjrt_plugin","title":"Convert to PJRT Plugin — as_pjrt_plugin","text":"Convert platform name PJRT plugin verify object already plugin.","code":""},{"path":"/reference/as_pjrt_plugin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to PJRT Plugin — as_pjrt_plugin","text":"","code":"as_pjrt_plugin(x)"},{"path":"/reference/as_pjrt_plugin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to PJRT Plugin — as_pjrt_plugin","text":"x () Object convert PJRT plugin. Currently supports PJRTPlugin character(1).","code":""},{"path":"/reference/as_pjrt_plugin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to PJRT Plugin — as_pjrt_plugin","text":"PJRTPlugin","code":""},{"path":"/reference/as_pjrt_plugin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert to PJRT Plugin — as_pjrt_plugin","text":"","code":"# Convert from platform name plugin <- as_pjrt_plugin(\"cpu\") plugin #> <PJRTPlugin:cpu>"},{"path":"/reference/devices.html","id":null,"dir":"Reference","previous_headings":"","what":"Devices — devices","title":"Devices — devices","text":"Get addressable devices PJRT client.","code":""},{"path":"/reference/devices.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Devices — devices","text":"","code":"devices(client = NULL)"},{"path":"/reference/devices.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Devices — devices","text":"client (PJRTClient) Object convertible PJRTClient.","code":""},{"path":"/reference/devices.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Devices — devices","text":"list PJRTDevice","code":""},{"path":"/reference/devices.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Devices — devices","text":"","code":"# Create client (defaults to CPU) client <- pjrt_client() devices(client) #> [[1]] #> <CpuDevice(id=0)> #>"},{"path":"/reference/elt_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Element Type — elt_type","title":"Element Type — elt_type","text":"Get element type buffer.","code":""},{"path":"/reference/elt_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Element Type — elt_type","text":"","code":"elt_type(x)"},{"path":"/reference/elt_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Element Type — elt_type","text":"x (PJRTBuffer) Buffer.","code":""},{"path":"/reference/elt_type.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Element Type — elt_type","text":"","code":"buf <- pjrt_buffer(c(1.0, 2.0, 3.0)) elt_type(buf) #> <f32>"},{"path":"/reference/format_buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Format Buffer Data — format_buffer","title":"Format Buffer Data — format_buffer","text":"Formats buffer data character vector string representations individual elements suitable stableHLO.","code":""},{"path":"/reference/format_buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format Buffer Data — format_buffer","text":"","code":"format_buffer(buffer)"},{"path":"/reference/format_buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format Buffer Data — format_buffer","text":"buffer (PJRTBuffer) PJRT buffer object.","code":""},{"path":"/reference/format_buffer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format Buffer Data — format_buffer","text":"character() character vector containing formatted elements.","code":""},{"path":"/reference/format_buffer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format Buffer Data — format_buffer","text":"","code":"buf <- pjrt_buffer(c(1.5, 2.5, 3.5)) format_buffer(buf) #> [1] \"1.50000000e+00\" \"2.50000000e+00\" \"3.50000000e+00\""},{"path":"/reference/is_ready.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an async operation is ready — is_ready","title":"Check if an async operation is ready — is_ready","text":"Non-blocking check see async operation completed.","code":""},{"path":"/reference/is_ready.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an async operation is ready — is_ready","text":"","code":"is_ready(x, ...)"},{"path":"/reference/is_ready.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an async operation is ready — is_ready","text":"x async value object. ... Additional arguments (unused).","code":""},{"path":"/reference/is_ready.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an async operation is ready — is_ready","text":"TRUE operation completed, FALSE otherwise.","code":""},{"path":"/reference/pjrt-package.html","id":null,"dir":"Reference","previous_headings":"","what":"pjrt: R Interface to PJRT — pjrt-package","title":"pjrt: R Interface to PJRT — pjrt-package","text":"Provides R interface PJRT (Pretty much Just another RunTime), allows run XLA stableHLO programs variety hardware backends including CPU, GPU, TPU.","code":""},{"path":"/reference/pjrt-package.html","id":"environment-variables","dir":"Reference","previous_headings":"","what":"Environment Variables","title":"pjrt: R Interface to PJRT — pjrt-package","text":"Configuration options provided XLA XLA provides various configuration options, documentation scattered across various websites. options include: TF_CPP_MIN_LOG_LEVEL: Logging level PJRT C++ API: 0: shows info, warnings errors 1: shows warnings errors 2: shows errors 3: shows nothing XLA_FLAGS: See openxla website information. Configuration options provided package PJRT_PLATFORM: Default platform use, falls back \"cpu\". PJRT_PLUGIN_PATH_<PLATFORM>: Path custom plugin library file specific platform (e.g., PJRT_PLUGIN_PATH_CPU, PJRT_PLUGIN_PATH_CUDA, PJRT_PLUGIN_PATH_METAL). set, package use path instead downloading plugin. PJRT_PLUGIN_URL_<PLATFORM>: URL download plugin specific platform (e.g., PJRT_PLUGIN_URL_CPU, PJRT_PLUGIN_URL_CUDA, PJRT_PLUGIN_URL_METAL). set, overrides default plugin download URL. PJRT_ZML_ARTIFACT_VERSION: Version ZML artifacts download. used downloading plugins zml/pjrt-artifacts. PJRT_CPU_DEVICE_COUNT: number CPU devices use. Defaults 1. primarily intended testing purposes.","code":""},{"path":[]},{"path":"/reference/pjrt-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"pjrt: R Interface to PJRT — pjrt-package","text":"Maintainer: Sebastian Fischer seb.fischer@tutamail.com (ORCID) Authors: Daniel Falbel daniel@posit.co (ORCID)","code":""},{"path":"/reference/pjrt_array_promise.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a PJRT Array Promise (internal) — pjrt_array_promise","title":"Create a PJRT Array Promise (internal) — pjrt_array_promise","text":"Internal constructor async device--host transfer results. Users call directly - use as_array_async() instead.","code":""},{"path":"/reference/pjrt_array_promise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a PJRT Array Promise (internal) — pjrt_array_promise","text":"","code":"pjrt_array_promise(data, event, dtype, dims)"},{"path":"/reference/pjrt_array_promise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a PJRT Array Promise (internal) — pjrt_array_promise","text":"data XPtr std::vector<uint8_t> holding raw bytes (row-major). event PJRTEvent external pointer (NULL). dtype Element type string (e.g., \"f32\", \"i32\"). dims Integer vector dimensions.","code":""},{"path":"/reference/pjrt_array_promise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a PJRT Array Promise (internal) — pjrt_array_promise","text":"pjrt_array_promise object.","code":""},{"path":"/reference/pjrt_buffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a PJRT Buffer — pjrt_buffer","title":"Create a PJRT Buffer — pjrt_buffer","text":"Create PJRT Buffer R object. numeric PJRT buffer array 0-dimensional arrays used scalars. pjrt_buffer create array dimensions (1) vector length 1, pjrt_scalar create 0-dimensional array R vector length 1. create empty buffer (least one dimension must 0), use pjrt_empty. Important: checks performed creating buffer, need ensure data fits selected element type (e.g., prevent buffer overflow) NA values present.","code":""},{"path":"/reference/pjrt_buffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a PJRT Buffer — pjrt_buffer","text":"","code":"pjrt_buffer(data, dtype = NULL, device = NULL, shape = NULL, ...)  pjrt_scalar(data, dtype = NULL, device = NULL, ...)  pjrt_empty(dtype, shape, device = NULL)"},{"path":"/reference/pjrt_buffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a PJRT Buffer — pjrt_buffer","text":"data () Data convert PJRTBuffer. dtype (NULL | character(1)) type buffer. Currently supported types : \"pred\": predicate (.e. boolean) \"{s,u}{8,16,32,64}\": Signed unsigned integer (integer data). \"f{32,64}\": Floating point (double integer data). default (NULL) depends method: logical -> \"pred\" integer -> \"i32\" double -> \"f32\" raw -> must supplied device (NULL | PJRTDevice | character(1)) PJRTDevice object name platform use (\"cpu\", \"cuda\", ...), case first device platform used. default use CPU platform, can configured via PJRT_PLATFORM environment variable. shape (NULL | integer()) dimensions buffer. default (NULL) infer data possible. default (NULL) depends method. ... () Additional arguments. raw types, includes: row_major: Whether read data row-major format column-major format. R uses column-major format.","code":""},{"path":"/reference/pjrt_buffer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a PJRT Buffer — pjrt_buffer","text":"PJRTBuffer","code":""},{"path":"/reference/pjrt_buffer.html","id":"extractors","dir":"Reference","previous_headings":"","what":"Extractors","title":"Create a PJRT Buffer — pjrt_buffer","text":"platform() -> character(1): platform name buffer (\"cpu\", \"cuda\", ...). device() -> PJRTDevice: device buffer (also includes device number) elt_type() -> PJRTElementType: element type buffer. shape() -> integer(): shape buffer.","code":""},{"path":"/reference/pjrt_buffer.html","id":"converters","dir":"Reference","previous_headings":"","what":"Converters","title":"Create a PJRT Buffer — pjrt_buffer","text":"as_array() -> array | vector: converting back R (vector used shape integer()). as_raw() -> raw raw vector.","code":""},{"path":"/reference/pjrt_buffer.html","id":"reading-and-writing","dir":"Reference","previous_headings":"","what":"Reading and Writing","title":"Create a PJRT Buffer — pjrt_buffer","text":"safetensors::safe_save_file writing safetensors file. safetensors::safe_load_file reading safetensors file.","code":""},{"path":"/reference/pjrt_buffer.html","id":"scalars","dir":"Reference","previous_headings":"","what":"Scalars","title":"Create a PJRT Buffer — pjrt_buffer","text":"calling function vector length 1, resulting shape 1L. create 0-dimensional buffer, use pjrt_scalar resulting shape integer().","code":""},{"path":"/reference/pjrt_buffer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a PJRT Buffer — pjrt_buffer","text":"","code":"# Create a buffer from a numeric vector buf <- pjrt_buffer(c(1, 2, 3, 4)) buf #> PJRTBuffer  #>  1.0000 #>  2.0000 #>  3.0000 #>  4.0000 #> [ CPUf32{4} ]   # Create a buffer from a matrix mat <- matrix(1:6, nrow = 2) buf <- pjrt_buffer(mat) buf #> PJRTBuffer  #>  1 3 5 #>  2 4 6 #> [ CPUi32{2x3} ]   # Create an integer buffer from an array arr <- array(1:8, dim = c(2, 2, 2)) buf <- pjrt_buffer(arr) # Create a scalar (0-dimensional array) scalar <- pjrt_scalar(42, dtype = \"f32\") scalar #> PJRTBuffer  #>  42.0000 #> [ CPUf32{} ]  # Create an empty buffer empty <- pjrt_empty(dtype = \"f32\", shape = c(0, 3)) empty #> PJRTBuffer  #> [ CPUf32{0x3} ]"},{"path":"/reference/pjrt_buffer_async.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a PJRT Buffer asynchronously — pjrt_buffer_async","title":"Create a PJRT Buffer asynchronously — pjrt_buffer_async","text":"Create PJRT Buffer R data asynchronously. Returns immediately pjrt_buffer_promise object. buffer valid immediately can used input operations. event signals PJRT done reading host memory. Use value() get PJRTBuffer (blocks ready). Use is_ready() check transfer completed (non-blocking).","code":""},{"path":"/reference/pjrt_buffer_async.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a PJRT Buffer asynchronously — pjrt_buffer_async","text":"","code":"pjrt_buffer_async(data, dtype = NULL, device = NULL, shape = NULL, ...)"},{"path":"/reference/pjrt_buffer_async.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a PJRT Buffer asynchronously — pjrt_buffer_async","text":"data () Data convert PJRTBuffer. dtype (NULL | character(1)) type buffer. Currently supported types : \"pred\": predicate (.e. boolean) \"{s,u}{8,16,32,64}\": Signed unsigned integer (integer data). \"f{32,64}\": Floating point (double integer data). default (NULL) depends method: logical -> \"pred\" integer -> \"i32\" double -> \"f32\" raw -> must supplied device (NULL | PJRTDevice | character(1)) PJRTDevice object name platform use (\"cpu\", \"cuda\", ...), case first device platform used. default use CPU platform, can configured via PJRT_PLATFORM environment variable. shape (NULL | integer()) dimensions buffer. default (NULL) infer data possible. default (NULL) depends method. ... () Additional arguments. raw types, includes: row_major: Whether read data row-major format column-major format. R uses column-major format.","code":""},{"path":"/reference/pjrt_buffer_async.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a PJRT Buffer asynchronously — pjrt_buffer_async","text":"pjrt_buffer_promise object. Call value() get PJRTBuffer.","code":""},{"path":[]},{"path":"/reference/pjrt_buffer_async.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a PJRT Buffer asynchronously — pjrt_buffer_async","text":"","code":"# Create a buffer asynchronously x <- pjrt_buffer_async(c(1.0, 2.0, 3.0, 4.0), shape = c(2, 2), dtype = \"f32\")  # Check if ready (non-blocking) is_ready(x) #> [1] TRUE  # Get the buffer (blocks if not ready) buf <- value(x)"},{"path":"/reference/pjrt_buffer_promise.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a PJRT Buffer Promise (internal) — pjrt_buffer_promise","title":"Create a PJRT Buffer Promise (internal) — pjrt_buffer_promise","text":"Internal constructor async buffer results. Users call directly - use pjrt_execute_async() pjrt_buffer_async() instead. buffer valid immediately can used subsequent operations (PJRT handles dependencies internally). Call value() block operation complete.","code":""},{"path":"/reference/pjrt_buffer_promise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a PJRT Buffer Promise (internal) — pjrt_buffer_promise","text":"","code":"pjrt_buffer_promise(buffer, event, data_holder = NULL)"},{"path":"/reference/pjrt_buffer_promise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a PJRT Buffer Promise (internal) — pjrt_buffer_promise","text":"buffer PJRTBuffer external pointer (valid immediately). event PJRTEvent external pointer (NULL already complete). data_holder Optional XPtr keeping host data alive transfer completes.","code":""},{"path":"/reference/pjrt_buffer_promise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a PJRT Buffer Promise (internal) — pjrt_buffer_promise","text":"pjrt_buffer_promise object.","code":""},{"path":"/reference/pjrt_client.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Client — pjrt_client","title":"Create a Client — pjrt_client","text":"Create PJRT client specific device.","code":""},{"path":"/reference/pjrt_client.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Client — pjrt_client","text":"","code":"pjrt_client(platform = NULL, ...)"},{"path":"/reference/pjrt_client.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Client — pjrt_client","text":"platform (character(1) | NULL) Platform name (e.g., \"cpu\", \"cuda\", \"metal\"). NULL, use PJRT_PLATFORM environment variable default \"cpu\". ... Additional options passed PJRT client creation. CPU clients, can pass cpu_device_count specify number CPU devices. can also configure via PJRT_CPU_DEVICE_COUNT environment variable.","code":""},{"path":"/reference/pjrt_client.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Client — pjrt_client","text":"PJRTClient","code":""},{"path":"/reference/pjrt_client.html","id":"extractors","dir":"Reference","previous_headings":"","what":"Extractors","title":"Create a Client — pjrt_client","text":"platform() character(1) representation platform. devices() list PJRTDevice objects.","code":""},{"path":"/reference/pjrt_client.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Client — pjrt_client","text":"","code":"# Create a client (defaults to CPU) client <- pjrt_client() client #> <PJRTClient:cpu>"},{"path":"/reference/pjrt_compile.html","id":null,"dir":"Reference","previous_headings":"","what":"Compile a Program — pjrt_compile","title":"Compile a Program — pjrt_compile","text":"Compile PJRTProgram program PJRTExecutable.","code":""},{"path":"/reference/pjrt_compile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compile a Program — pjrt_compile","text":"","code":"pjrt_compile(   program,   compile_options = new_compile_options(),   client = pjrt_client() )"},{"path":"/reference/pjrt_compile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compile a Program — pjrt_compile","text":"program (character(1)) program compile. compile_options (PJRTCompileOptions) Compile options. client (PJRTClient | character(1)) PJRT client object name platform use (\"cpu\", \"cuda\", ...), client created.","code":""},{"path":"/reference/pjrt_compile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compile a Program — pjrt_compile","text":"PJRTExecutable","code":""},{"path":"/reference/pjrt_compile.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compile a Program — pjrt_compile","text":"","code":"# Create a simple program src <- r\"( func.func @main(\\%arg0: tensor<2xf32>) -> tensor<2xf32> {   return \\%arg0 : tensor<2xf32> } )\" prog <- pjrt_program(src = src) exec <- pjrt_compile(prog) #> Error: -:2:17: error: unexpected character #> <unknown>:0: error: Failed to parse using StableHLO v1.13.2, this could indicate forward incompatibility, >12w old unsupported plugin, or a portable artifact that needs to be further downgraded."},{"path":"/reference/pjrt_device.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a PJRT Device — pjrt_device","title":"Create a PJRT Device — pjrt_device","text":"Create PJRT Device R object.","code":""},{"path":"/reference/pjrt_device.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a PJRT Device — pjrt_device","text":"","code":"pjrt_device(device)"},{"path":"/reference/pjrt_device.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a PJRT Device — pjrt_device","text":"device () device.","code":""},{"path":"/reference/pjrt_device.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a PJRT Device — pjrt_device","text":"PJRTDevice","code":""},{"path":"/reference/pjrt_device.html","id":"extractors","dir":"Reference","previous_headings":"","what":"Extractors","title":"Create a PJRT Device — pjrt_device","text":"platform() character(1) representation platform.","code":""},{"path":"/reference/pjrt_device.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a PJRT Device — pjrt_device","text":"","code":"# Show available devices for CPU client devices(pjrt_client(\"cpu\")) #> [[1]] #> <CpuDevice(id=0)> #>  # Create device 0 for CPU client dev <- pjrt_device(\"cpu:0\") dev #> <CpuDevice(id=0)>"},{"path":"/reference/pjrt_execute.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute a PJRT program — pjrt_execute","title":"Execute a PJRT program — pjrt_execute","text":"Execute PJRT program given inputs execution options. Important: Arguments passed position names ignored. Inputs can PJRTBuffer objects buffer promises (pjrt_buffer_promise). Buffer promises resolved automatically execution.","code":""},{"path":"/reference/pjrt_execute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute a PJRT program — pjrt_execute","text":"","code":"pjrt_execute(executable, ..., execution_options = NULL, simplify = TRUE)"},{"path":"/reference/pjrt_execute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute a PJRT program — pjrt_execute","text":"executable (PJRTLoadedExecutable) PJRT program. ... (PJRTBuffer | pjrt_buffer_promise) Inputs program. Named ignored arguments passed order. execution_options (PJRTExecuteOptions) Optional execution options configuring buffer donation settings. simplify (logical(1)) TRUE (default), single output returned PJRTBuffer. FALSE, single output returned list length 1 containing PJRTBuffer.","code":""},{"path":"/reference/pjrt_execute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute a PJRT program — pjrt_execute","text":"PJRTBuffer | list PJRTBuffers","code":""},{"path":"/reference/pjrt_execute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute a PJRT program — pjrt_execute","text":"","code":"# Create and compile a simple identity program src <- r\"( func.func @main(   \\%x: tensor<2x2xf32>,   \\%y: tensor<2x2xf32> ) -> tensor<2x2xf32> {   \\%0 = \"stablehlo.add\"(\\%x, \\%y) : (tensor<2x2xf32>, tensor<2x2xf32>) -> tensor<2x2xf32>   \"func.return\"(\\%0): (tensor<2x2xf32>) -> () } )\" prog <- pjrt_program(src = src) exec <- pjrt_compile(prog) #> Error: -:3:3: error: unexpected character #> <unknown>:0: error: Failed to parse using StableHLO v1.13.2, this could indicate forward incompatibility, >12w old unsupported plugin, or a portable artifact that needs to be further downgraded.  # Execute with input x <- pjrt_buffer(c(1.0, 2.0, 3.0, 4.0), shape = c(2, 2), dtype = \"f32\") y <- pjrt_buffer(c(5, 6, 7, 8), shape = c(2, 2), dtype = \"f32\") pjrt_execute(exec, x, y) #> Error: object 'exec' not found"},{"path":"/reference/pjrt_execute_async.html","id":null,"dir":"Reference","previous_headings":"","what":"Execute a PJRT program asynchronously — pjrt_execute_async","title":"Execute a PJRT program asynchronously — pjrt_execute_async","text":"Execute PJRT program asynchronously given inputs. Returns immediately buffer promise(s) can awaited later. Use value() get result (blocks ready). Use is_ready() check execution completed (non-blocking). Use as_array_async() chain async buffer--host transfer. Inputs can PJRTBuffer objects buffer promises (pjrt_buffer_promise). Buffer promises resolved automatically execution.","code":""},{"path":"/reference/pjrt_execute_async.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Execute a PJRT program asynchronously — pjrt_execute_async","text":"","code":"pjrt_execute_async(executable, ..., execution_options = NULL, simplify = TRUE)"},{"path":"/reference/pjrt_execute_async.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Execute a PJRT program asynchronously — pjrt_execute_async","text":"executable (PJRTLoadedExecutable) PJRT program. ... (PJRTBuffer | pjrt_buffer_promise) Inputs program. Named ignored arguments passed order. execution_options (PJRTExecuteOptions) Optional execution options configuring buffer donation settings. simplify (logical(1)) TRUE (default), single output returned PJRTBuffer. FALSE, single output returned list length 1 containing PJRTBuffer.","code":""},{"path":"/reference/pjrt_execute_async.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Execute a PJRT program asynchronously — pjrt_execute_async","text":"pjrt_buffer_promise object (list multiple outputs). Call value() get PJRTBuffer.","code":""},{"path":[]},{"path":"/reference/pjrt_execute_async.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Execute a PJRT program asynchronously — pjrt_execute_async","text":"","code":"# Create and compile a simple program src <- r\"( func.func @main(\\%x: tensor<2x2xf32>) -> tensor<2x2xf32> {   \"func.return\"(\\%x): (tensor<2x2xf32>) -> () } )\" prog <- pjrt_program(src = src) exec <- pjrt_compile(prog) #> Error: -:2:17: error: unexpected character #> <unknown>:0: error: Failed to parse using StableHLO v1.13.2, this could indicate forward incompatibility, >12w old unsupported plugin, or a portable artifact that needs to be further downgraded.  # Execute asynchronously x <- pjrt_buffer(c(1.0, 2.0, 3.0, 4.0), shape = c(2, 2), dtype = \"f32\") result <- pjrt_execute_async(exec, x) #> Error: object 'exec' not found  # Check if ready (non-blocking) is_ready(result) #> Error: object 'result' not found  # Get the result (blocks if not ready) value(result) #> Error: object 'result' not found  # Chain with async buffer-to-host transfer arr <- as_array_async(result) #> Error: object 'result' not found value(arr) #> Error: object 'arr' not found"},{"path":"/reference/pjrt_execution_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Execution Options — pjrt_execution_options","title":"Create Execution Options — pjrt_execution_options","text":"Create execution options configuring PJRT program executed, including buffer donation settings. Important: enough mark buffer donatable (donatable) runtime. program also needs specify compile-time via input-output aliasing (stableHLO attribute tf.aliasing_output).","code":""},{"path":"/reference/pjrt_execution_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Execution Options — pjrt_execution_options","text":"","code":"pjrt_execution_options(non_donatable_input_indices = integer(), launch_id = 0L)"},{"path":"/reference/pjrt_execution_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Execution Options — pjrt_execution_options","text":"non_donatable_input_indices (integer()) vector input buffer indices donated execution (0-based). Buffer donation allows runtime reuse input buffers outputs possible, can improve performance. However, input buffer referenced multiple times needs preserved, marked non-donatable. launch_id (integer(1)) optional launch identifier multi-device executions. can used detect scheduling errors multi-host programs.","code":""},{"path":"/reference/pjrt_execution_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Execution Options — pjrt_execution_options","text":"PJRTExecuteOptions","code":""},{"path":"/reference/pjrt_execution_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Execution Options — pjrt_execution_options","text":"","code":"# Create default execution options opts <- pjrt_execution_options()  # Mark buffer 0 as non-donatable opts <- pjrt_execution_options(non_donatable_input_indices = 0L)"},{"path":"/reference/pjrt_plugin.html","id":null,"dir":"Reference","previous_headings":"","what":"Create PJRT Plugin — pjrt_plugin","title":"Create PJRT Plugin — pjrt_plugin","text":"Create PJRT plugin specific platform.","code":""},{"path":"/reference/pjrt_plugin.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create PJRT Plugin — pjrt_plugin","text":"","code":"pjrt_plugin(platform)"},{"path":"/reference/pjrt_plugin.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create PJRT Plugin — pjrt_plugin","text":"platform (character(1)) Platform name (e.g., \"cpu\", \"cuda\", \"metal\").","code":""},{"path":"/reference/pjrt_plugin.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create PJRT Plugin — pjrt_plugin","text":"PJRTPlugin","code":""},{"path":"/reference/pjrt_plugin.html","id":"extractors","dir":"Reference","previous_headings":"","what":"Extractors","title":"Create PJRT Plugin — pjrt_plugin","text":"plugin_attributes() -> list(): attributes plugin.","code":""},{"path":"/reference/pjrt_plugin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create PJRT Plugin — pjrt_plugin","text":"","code":"plugin <- pjrt_plugin(\"cpu\") plugin #> <PJRTPlugin:cpu>"},{"path":"/reference/pjrt_program.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a PJRTProgram — pjrt_program","title":"Create a PJRTProgram — pjrt_program","text":"Create program string file path.","code":""},{"path":"/reference/pjrt_program.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a PJRTProgram — pjrt_program","text":"","code":"pjrt_program(src = NULL, path = NULL, format = c(\"mlir\", \"hlo\"))"},{"path":"/reference/pjrt_program.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a PJRTProgram — pjrt_program","text":"src (character(1)) Source code. path (character(1)) Path program file. format (character(1)) One \"mlir\" \"hlo\".","code":""},{"path":"/reference/pjrt_program.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a PJRTProgram — pjrt_program","text":"PJRTProgram","code":""},{"path":"/reference/pjrt_program.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a PJRTProgram — pjrt_program","text":"","code":"# Create a program from source src <- \" func.func @main(%arg0: tensor<2xf32>) -> tensor<2xf32> {   return %arg0 : tensor<2xf32> } \" prog <- pjrt_program(src = src) prog #> PJRTProgram(format=mlir, code_size=92) #>  #> func.func @main(%arg0: tensor<2xf32>) -> tensor<2xf32> { #>   return %arg0 : tensor<2xf32> #> } #>  #>"},{"path":"/reference/platform.html","id":null,"dir":"Reference","previous_headings":"","what":"Platform Name — platform","title":"Platform Name — platform","text":"Get platform name PJRT buffer.","code":""},{"path":"/reference/platform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Platform Name — platform","text":"","code":"platform(x, ...)"},{"path":"/reference/platform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Platform Name — platform","text":"x (PJRTBuffer) buffer. ... Additional arguments (unused).","code":""},{"path":"/reference/platform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Platform Name — platform","text":"character(1)","code":""},{"path":"/reference/platform.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Platform Name — platform","text":"","code":"buf <- pjrt_buffer(c(1, 2, 3)) platform(buf) #> [1] \"cpu\""},{"path":"/reference/plugin_attributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Get Plugin Attributes — plugin_attributes","title":"Get Plugin Attributes — plugin_attributes","text":"Get attributes PJRT plugin. commonly includes: xla_version stablehlo_current_version stablehlo_minimum_version implementation depends plugin.","code":""},{"path":"/reference/plugin_attributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get Plugin Attributes — plugin_attributes","text":"","code":"plugin_attributes(plugin)"},{"path":"/reference/plugin_attributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get Plugin Attributes — plugin_attributes","text":"plugin (PJRTPlugin | character(1)) plugin (platform name) get attributes .","code":""},{"path":"/reference/plugin_attributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get Plugin Attributes — plugin_attributes","text":"named list()","code":""},{"path":"/reference/plugin_attributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get Plugin Attributes — plugin_attributes","text":"","code":"plugin_attributes(\"cpu\") #> $xla_version #> [1] 2 #>  #> $stablehlo_current_version #> [1]  1 13  2 #>  #> $stablehlo_minimum_version #> [1] 0 9 0 #>"},{"path":"/reference/plugin_client_create.html","id":null,"dir":"Reference","previous_headings":"","what":"Create PJRT Client — plugin_client_create","title":"Create PJRT Client — plugin_client_create","text":"Create PJRT client specific plugin platform.","code":""},{"path":"/reference/plugin_client_create.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create PJRT Client — plugin_client_create","text":"","code":"plugin_client_create(plugin, platform, options = list())"},{"path":"/reference/plugin_client_create.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create PJRT Client — plugin_client_create","text":"plugin (PJRTPlugin) plugin create client . platform (character(1)) platform create client . options (list()) Additional options pass client.","code":""},{"path":"/reference/plugin_client_create.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create PJRT Client — plugin_client_create","text":"PJRTClient","code":""},{"path":"/reference/plugin_is_downloaded.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if Plugin is Downloaded — plugin_is_downloaded","title":"Check if Plugin is Downloaded — plugin_is_downloaded","text":"Check plugin downloaded.","code":""},{"path":"/reference/plugin_is_downloaded.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if Plugin is Downloaded — plugin_is_downloaded","text":"","code":"plugin_is_downloaded(platform = NULL)"},{"path":"/reference/plugin_is_downloaded.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if Plugin is Downloaded — plugin_is_downloaded","text":"platform (character(1)) Platform name.","code":""},{"path":"/reference/plugin_is_downloaded.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if Plugin is Downloaded — plugin_is_downloaded","text":"logical(1)","code":""},{"path":"/reference/plugin_is_downloaded.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if Plugin is Downloaded — plugin_is_downloaded","text":"","code":"# Check if CPU plugin is downloaded plugin_is_downloaded(\"cpu\") #> [1] TRUE"},{"path":"/reference/print.PJRTBuffer.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a PJRT Buffer — print.PJRTBuffer","title":"Print a PJRT Buffer — print.PJRTBuffer","text":"Print PJRTBuffer.","code":""},{"path":"/reference/print.PJRTBuffer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a PJRT Buffer — print.PJRTBuffer","text":"","code":"# S3 method for class 'PJRTBuffer' print(   x,   max_rows = getOption(\"pjrt.print_max_rows\", 30L),   max_width = getOption(\"pjrt.print_max_width\", 85L),   max_rows_slice = getOption(\"pjrt.print_max_rows_slice\", max_rows),   header = TRUE,   ... )"},{"path":"/reference/print.PJRTBuffer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a PJRT Buffer — print.PJRTBuffer","text":"x (PJRTBuffer) buffer. max_rows (integer(1)) maximum number rows print, excluding header footer. max_width (integer(1)) maximum width (characters) printed buffer. Set negative values limit. Note small values, actual printed width might slightly smaller least one column printed. Also, limit affects printed rows containing actual data, rows might exceed width. max_rows_slice (integer(1)) maximum number rows print slice. header (logical(1)) Whether print header. ... Additional arguments (unused).","code":""},{"path":"/reference/reexports.html","id":null,"dir":"Reference","previous_headings":"","what":"Objects exported from other packages — reexports","title":"Objects exported from other packages — reexports","text":"objects imported packages. Follow links see documentation. tengen as_array, as_raw, device, dtype, shape","code":""},{"path":"/reference/value.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the value of an async operation — value","title":"Get the value of an async operation — value","text":"Materialize return result async operation. Blocks operation complete finished yet. Returns PJRTBuffer pjrt_buffer_promise R array pjrt_array_promise.","code":""},{"path":"/reference/value.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the value of an async operation — value","text":"","code":"value(x, ...)"},{"path":"/reference/value.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the value of an async operation — value","text":"x async value object. ... Additional arguments (unused).","code":""},{"path":"/reference/value.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the value of an async operation — value","text":"materialized value.","code":""}]
